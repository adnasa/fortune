<!DOCTYPE html><!--

This page is automatically generated. See:
https://github.com/fortunejs/fortune/tree/master/website

--><html lang="en"><head><title>Fortune.js</title><meta name="description" content="Data transformation middleware for Node.js and web browsers."><meta name="keywords" content="application,adapter,api,data,hypermedia,rest,serializer,system"><meta name="viewport" content="width=device-width,initial-scale=1"><meta charset="utf-8"><link rel="icon" href="./assets/piggu.png"><link rel="stylesheet" href="./assets/index.css"></head><body><header><a href="https://github.com/fortunejs/fortune" id="corner"><span>Fork on</span> GitHub</a> <a href="./"><img src="./assets/piggu.svg" alt="Piggu" class="emblem"></a> <a href="./"><img src="./assets/fortune_type.svg" alt="Fortune.js" class="logo-type"></a><nav><a href="./getting-started/">Getting Started</a><!--
        --><a href="./api/">API Reference</a><!--
        --><a href="./plugins/">Plugins</a></nav></header><article><p>Fortune.js is an <a href="http://systems-analysis.net/architecture/introduction.html">application system</a> for Node.js and web browsers, including the data access layer (adapter), business logic layer (transform), and presentation layer (serializer). These layers working together allow for multiple data sources to be exposed via multiple formats through a uniform interface.</p><p>The latest version is <strong>1.4.21</strong>, get it from <code>npm</code>:</p><pre class="install"><code>npm install <span class="hljs-literal">fortune</span> <span class="hljs-string">--save</span></code></pre><h4 id="approach">Approach<a class="anchor" href="#approach" title="Link to this section “Approach”">#</a></h4><blockquote><p>Most web apps at heart are user experience and business logic around a persistent store.</p></blockquote><p>Fortune.js is built with a reductionist approach to application development. It has one primary interface to do I/O, the <code>request</code> method, which dynamically dispatches <code>Adapter</code>, <code>Serializer</code>, and <code>transform</code> calls. Networking wrappers call the <code>request</code> method, so it is not coupled with any external protocol. Typically it is not needed to use the <code>request</code> method directly.</p><p>The <code>Adapter</code> abstraction allows for multiple persistence back-ends, such as common server-side databases like MongoDB and Postgres, and IndexedDB and Web Storage in the web browser.</p><p>The <code>Serializer</code> abstraction allows for multiple serialization formats, including hypermedia media types such as Micro API, standard input formats such as URL encoded and form data, and custom serializers for HTML.</p><h2 id="example">Example<a class="anchor" href="#example" title="Link to this section “Example”">#</a></h2><p>The only necessary input is record type definitions. Record types in Fortune.js are like what <code>struct</code> is in C: declarations of complex data types. Let&#39;s model Twitter&#39;s basic functionality:</p><pre><code class="lang-js"><span class="hljs-comment">// store.js</span>
const fortune = require(<span class="hljs-string">'fortune'</span>)

module.exports = fortune()

.defineType(<span class="hljs-string">'user'</span>, {
<span class="hljs-label">  name:</span> { <span class="hljs-string">type:</span> String },

  <span class="hljs-comment">// Following and followers are inversely related (many-to-many).</span>
<span class="hljs-label">  following:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'user'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'followers'</span>, <span class="hljs-string">isArray:</span> <span class="hljs-literal">true</span> },
<span class="hljs-label">  followers:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'user'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'following'</span>, <span class="hljs-string">isArray:</span> <span class="hljs-literal">true</span> },

  <span class="hljs-comment">// Many-to-one relationship of user posts to post author.</span>
<span class="hljs-label">  posts:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'post'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'author'</span>, <span class="hljs-string">isArray:</span> <span class="hljs-literal">true</span> }
})

.defineType(<span class="hljs-string">'post'</span>, {
<span class="hljs-label">  message:</span> { <span class="hljs-string">type:</span> String },

  <span class="hljs-comment">// One-to-many relationship of post author to user posts.</span>
<span class="hljs-label">  author:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'user'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'posts'</span> }
})
</code></pre><p>By default, the data is persisted in memory. There are adapters for databases such as <a href="https://github.com/fortunejs/fortune-mongodb">MongoDB</a>, <a href="https://github.com/fortunejs/fortune-postgres">Postgres</a>, and <a href="https://github.com/fortunejs/fortune-nedb">NeDB</a>. Then let&#39;s add a HTTP server:</p><pre><code class="lang-js"><span class="hljs-comment">// server.js</span>
const http = <span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">(<span class="hljs-string">'http'</span>)</span></span>
const fortune = <span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">(<span class="hljs-string">'fortune'</span>)</span></span>
const store = <span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">(<span class="hljs-string">'./store'</span>)</span></span>

<span class="hljs-comment">// The `fortune.net.http` helper function returns a listener function which</span>
<span class="hljs-comment">// does content negotiation, and maps the internal response to a HTTP response.</span>
const server = http.<span class="hljs-function"><span class="hljs-title">createServer</span><span class="hljs-params">(fortune.net.http(store)</span></span>)

store.<span class="hljs-function"><span class="hljs-title">connect</span><span class="hljs-params">()</span></span>.<span class="hljs-function"><span class="hljs-title">then</span><span class="hljs-params">(()</span></span> =&gt; server.<span class="hljs-function"><span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-number">1337</span>)</span></span>)
</code></pre><p>This yields an <em>ad hoc</em> JSON-over-HTTP API. There are serializers for <a href="https://github.com/fortunejs/fortune-micro-api">Micro API</a> (JSON-LD) and <a href="https://github.com/fortunejs/fortune-json-api">JSON API</a>.</p><p>See the <a href="http://fortunejs.com/plugins/">plugins page</a> for more details.</p></article><footer><p>&copy; 2015 &nbsp;&mdash;&nbsp; <a href="https://raw.githubusercontent.com/fortunejs/fortune/master/LICENSE">MIT License</a></p><p>福</p></footer></body></html>